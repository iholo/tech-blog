<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xie sm&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iholo.me/"/>
  <updated>2019-11-02T08:24:33.257Z</updated>
  <id>http://iholo.me/</id>
  
  <author>
    <name>Xie sm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ffmpeg常用命令</title>
    <link href="http://iholo.me/posts/1k42c61fk/"/>
    <id>http://iholo.me/posts/1k42c61fk/</id>
    <published>2019-11-01T22:35:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ffmpeg常用命令"><a href="#ffmpeg常用命令" class="headerlink" title="ffmpeg常用命令"></a>ffmpeg常用命令</h2><p>循环播放</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i video.ts -c copy -f mpegts udp://127.0.0.1:12345</span><br></pre></td></tr></table></figure><p>循环播放(Linux)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> cat SpaceX.mp4 ; <span class="keyword">done</span> | ffmpeg -re -i pipe:0 -c copy  -b:v 2M -maxrate:v 2M -f mpegts udp://127.0.0.1:12345</span><br></pre></td></tr></table></figure><p>QSV硬解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -stream_loop -1 -re -hwaccel qsv -c:v hevc_qsv -i SpaceX.mp4  -c:v hevc_qsv -c:a aac -vf <span class="string">'scale_qsv=w=1920:h=1080'</span> -b:v 3M -maxrate:v 3M -f mpegts udp://127.0.0.1:12345</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ffmpeg常用命令&quot;&gt;&lt;a href=&quot;#ffmpeg常用命令&quot; class=&quot;headerlink&quot; title=&quot;ffmpeg常用命令&quot;&gt;&lt;/a&gt;ffmpeg常用命令&lt;/h2&gt;&lt;p&gt;循环播放&lt;/p&gt;
&lt;figure class=&quot;highlight bash
      
    
    </summary>
    
      <category term="ffmpeg" scheme="http://iholo.me/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="http://iholo.me/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://iholo.me/posts/ki92x4hcuk/"/>
    <id>http://iholo.me/posts/ki92x4hcuk/</id>
    <published>2019-11-01T22:35:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><p>获取CPUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode -t 4 | grep ID |sort -u |awk -F<span class="string">': '</span> <span class="string">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure><p>Perl替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -pi -e <span class="string">'s|ABCD|Linux|g'</span> `find ./ -<span class="built_in">type</span> f` </span><br><span class="line">将调用perl执行一条替换命令，把find命令找到的所有文件内容中的ABCD替换为Linux</span><br><span class="line">eg: perl -pi -e <span class="string">'s|http://static.abc.com|http://oss.abc.com|g'</span> `find ./ -name <span class="string">'*.json'</span>`</span><br></pre></td></tr></table></figure><p>待整理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsblk  查看当前磁盘情况</span><br><span class="line">df -lh  查看文件系统情况 -l 查看挂载点</span><br><span class="line">parted -l 会列出文件系统类型</span><br><span class="line">fdisk -l 查看当前未挂载硬盘</span><br><span class="line">du -h 查看文件或文件夹大小</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h2&gt;&lt;p&gt;获取CPUID&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://iholo.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://iholo.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用命令</title>
    <link href="http://iholo.me/posts/kqxlsql/"/>
    <id>http://iholo.me/posts/kqxlsql/</id>
    <published>2019-11-01T22:35:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql常用命令"><a href="#Mysql常用命令" class="headerlink" title="Mysql常用命令"></a>Mysql常用命令</h2><p>安全模式启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysqld_safe --skip-grant-tables --skip-networking &amp;</span><br></pre></td></tr></table></figure><p>设置密码登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set plugin = &apos;mysql_native_password&apos; where User=&apos;root&apos;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>修改密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql; </span><br><span class="line">UPDATE user SET password=password(&apos;newpassword&apos;) WHERE user=&apos;root&apos;;  </span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>截断表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table table_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mysql常用命令&quot;&gt;&lt;a href=&quot;#Mysql常用命令&quot; class=&quot;headerlink&quot; title=&quot;Mysql常用命令&quot;&gt;&lt;/a&gt;Mysql常用命令&lt;/h2&gt;&lt;p&gt;安全模式启动&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mysqld_safe --skip-grant-tables --skip-networking &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置密码登录&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;update mysql.user set plugin = &amp;apos;mysql_native_password&amp;apos; where User=&amp;apos;root&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://iholo.me/categories/Mysql/"/>
    
    
      <category term="ffmpeg" scheme="http://iholo.me/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://iholo.me/posts/2f57a694/"/>
    <id>http://iholo.me/posts/2f57a694/</id>
    <published>2018-09-01T01:35:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</p></blockquote><p>一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.<br>“Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”.<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.</p><p>想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.<br>我们使用以下正则表达式来验证一个用户名:</p><p><img src="/images/regexp-cn.png" alt=""></p><p>以上的正则表达式可以接受 <code>john_doe</code>, <code>jo-hn_doe</code>, <code>john12_as</code>.<br>但不匹配<code>Jo</code>, 因为它包含了大写的字母而且太短了.</p><a id="more"></a><h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成.<br>例如: 一个正则表达式 <code>the</code>, 它表示一个规则: 由字母<code>t</code>开始,接着是<code>h</code>,再接着是<code>e</code>.</p><pre>"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">在线练习</a></p><p>正则表达式<code>123</code>匹配字符串<code>123</code>. 它逐个字符的与输入的正则表达式做比较.</p><p>正则表达式是大小写敏感的, 所以<code>The</code>不会匹配<code>the</code>.</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式主要依赖于元字符.<br>元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p><table><thead><tr><th style="text-align:center">元字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td>句号匹配任意单个字符除了换行符.</td></tr><tr><td style="text-align:center">[ ]</td><td>字符种类. 匹配方括号内的任意字符.</td></tr><tr><td style="text-align:center">[^ ]</td><td>否定的字符种类. 匹配除了方括号里的任意字符</td></tr><tr><td style="text-align:center">*</td><td>匹配&gt;=0个重复的在*号之前的字符.</td></tr><tr><td style="text-align:center">+</td><td>匹配&gt;=1个重复的+号前的字符.</td></tr><tr><td style="text-align:center">?</td><td>标记?之前的字符为可选.</td></tr><tr><td style="text-align:center">{n,m}</td><td>匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td></tr><tr><td style="text-align:center">(xyz)</td><td>字符集, 匹配与 xyz 完全相等的字符串.</td></tr><tr><td style="text-align:center">&#124;</td><td>或运算符,匹配符号前或后的字符.</td></tr><tr><td style="text-align:center">&#92;</td><td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code></td></tr><tr><td style="text-align:center">^</td><td>从开始行开始匹配.</td></tr><tr><td style="text-align:center">$</td><td>从末端开始匹配.</td></tr></tbody></table><p>点运算符 <code>.</code></p><p><code>.</code>是元字符中最简单的例子.<br><code>.</code>匹配任意单个字符, 但不匹配换行符.<br>例如, 表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串.</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>字符集也叫做字符类.<br>方括号用来指定一个字符集.<br>在方括号中使用连字符来指定字符集的范围.<br>在方括号中的字符集不关心顺序.<br>例如, 表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>.</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="noopener">在线练习</a></p><p>方括号的句号就表示句号.<br>表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="noopener">在线练习</a></p><h4 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h4><p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候, 它表示这个字符集是否定的.<br>例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h3><p>后面跟着元字符 <code>+</code>, <code>*</code> or <code>?</code> 的, 用来指定匹配子模式的次数.<br>这些元字符在不同的情况下有着不同的意思.</p><h4 id="号"><a href="#号" class="headerlink" title="* 号"></a><code>*</code> 号</h4><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次.<br>例如, 表达式 <code>a*</code> 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="noopener">在线练习</a></p><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.<br><code>*</code>和表示匹配空格的符号<code>\s</code>连起来用, 如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex">con<strong>cat</strong>enation</a>.</pre><p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="noopener">在线练习</a></p><h4 id="号-1"><a href="#号-1" class="headerlink" title="+ 号"></a><code>+</code> 号</h4><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次.<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着任意个字符的字符串.</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="noopener">在线练习</a></p><h4 id="号-2"><a href="#号-2" class="headerlink" title="? 号"></a><code>?</code> 号</h4><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选, 即出现 0 或 1 次.<br>例如, 表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>.</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="noopener">在线练习</a></p><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="号-3"><a href="#号-3" class="headerlink" title="{} 号"></a><code>{}</code> 号</h3><p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的次数.<br>例如,  表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字.</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="noopener">在线练习</a></p><p>我们可以省略第二个参数.<br>例如, <code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字.</p><p>如果逗号也省略掉则表示重复固定的次数.<br>例如, <code>[0-9]{3}</code> 匹配3位数字</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="noopener">在线练习</a></p><pre>"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.</pre><p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="特征标群"><a href="#特征标群" class="headerlink" title="(...) 特征标群"></a><code>(...)</code> 特征标群</h3><p>特征标群是一组写在 <code>(...)</code> 中的子模式. 例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="或运算符"><a href="#或运算符" class="headerlink" title="| 或运算符"></a><code>|</code> 或运算符</h3><p>或运算符就表示或, 用作判断条件.</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="转码特殊字符"><a href="#转码特殊字符" class="headerlink" title="转码特殊字符"></a>转码特殊字符</h3><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>.</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>在正则表达式中, 想要匹配指定开头或结尾的字符串就要使用到锚点. <code>^</code> 指定开头, <code>$</code> 指定结尾.</p><h4 id="号-4"><a href="#号-4" class="headerlink" title="^ 号"></a><code>^</code> 号</h4><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p><p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p><p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="noopener">在线练习</a></p><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="noopener">在线练习</a></p><h4 id="号-5"><a href="#号-5" class="headerlink" title="$  号"></a><code>$</code>  号</h4><p>同理于 <code>^</code> 号, <code>$</code> 号用来匹配字符是否是最后一个.</p><p>例如, <code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="noopener">在线练习</a></p><pre>"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><p>正则表达式提供一些常用的字符集简写. 如下:</p><table><thead><tr><th style="text-align:center">简写</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td>除换行符外的所有字符</td></tr><tr><td style="text-align:center">\w</td><td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td style="text-align:center">\W</td><td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td></tr><tr><td style="text-align:center">\d</td><td>匹配数字: <code>[0-9]</code></td></tr><tr><td style="text-align:center">\D</td><td>匹配非数字: <code>[^\d]</code></td></tr><tr><td style="text-align:center">\s</td><td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td style="text-align:center">\S</td><td>匹配所有非空格字符: <code>[^\s]</code></td></tr><tr><td style="text-align:center">\f</td><td>匹配一个换页符</td></tr><tr><td style="text-align:center">\n</td><td>匹配一个换行符</td></tr><tr><td style="text-align:center">\r</td><td>匹配一个回车符</td></tr><tr><td style="text-align:center">\t</td><td>匹配一个制表符</td></tr><tr><td style="text-align:center">\v</td><td>匹配一个垂直制表符</td></tr><tr><td style="text-align:center">\p</td><td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td></tr></tbody></table><h2 id="前后关联约束-前后预查"><a href="#前后关联约束-前后预查" class="headerlink" title="前后关联约束(前后预查)"></a>前后关联约束(前后预查)</h2><p>前置约束和后置约束都属于<strong>非捕获簇</strong>(用于匹配不在匹配列表中的格式).<br>前置约束用于判断所匹配的格式是否在另一个确定的格式之后.</p><p>例如, 我们想要获得所有跟在 <code>$</code> 符号后的数字, 我们可以使用正向向后约束 <code>(?&lt;=\$)[0-9\.]*</code>.<br>这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次.</p><p>前后关联约束如下:</p><table><thead><tr><th style="text-align:center">符号</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">?=</td><td>前置约束-存在</td></tr><tr><td style="text-align:center">?!</td><td>前置约束-排除</td></tr><tr><td style="text-align:center">?&lt;=</td><td>后置约束-存在</td></tr><tr><td style="text-align:center">?&lt;!</td><td>后置约束-排除</td></tr></tbody></table><h3 id="前置约束-存在"><a href="#前置约束-存在" class="headerlink" title="?=... 前置约束(存在)"></a><code>?=...</code> 前置约束(存在)</h3><p><code>?=...</code> 前置约束(存在), 表示第一部分表达式必须跟在 <code>?=...</code>定义的表达式之后.</p><p>返回结果只满足第一部分表达式.<br>定义一个前置约束(存在)要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. </p><p>前置约束的内容写在括号中的等号后面.<br>例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了前置约束(存在) <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre>[在线练习](https://regex101.com/r/IDDARt/1)###  `?!...` 前置约束-排除前置约束-排除 `?!` 用于筛选所有匹配结果, 筛选条件为 其后不跟随着定义的格式`前置约束-排除`  定义和 `前置约束(存在)` 一样, 区别就是 `=` 替换成 `!` 也就是 `(?!...)`.表达式 `(T|t)he(?!\sfat)` 匹配 `The` 和 `the`, 且其后不跟着 `(空格)fat`.<pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="lt-后置约束-存在"><a href="#lt-后置约束-存在" class="headerlink" title="?&lt;= ... 后置约束-存在"></a><code>?&lt;= ...</code> 后置约束-存在</h3><p>后置约束-存在 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 其前跟随着定义的格式.<br>例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p><pre>"(?<=(t|t)he\s)(fat|mat)" ==""> The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</=(t|t)he\s)(fat|mat)"></pre><p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="lt-后置约束-排除"><a href="#lt-后置约束-排除" class="headerlink" title="?&lt;!... 后置约束-排除"></a><code>?&lt;!...</code> 后置约束-排除</h3><p>后置约束-排除 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟着定义的格式.<br>例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="noopener">在线练习</a></p><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫修饰语, 因为它可以用来修改表达式的搜索结果.<br>这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.</p><table><thead><tr><th style="text-align:center">标志</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td>忽略大小写.</td></tr><tr><td style="text-align:center">g</td><td>全局搜索.</td></tr><tr><td style="text-align:center">m</td><td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td></tr></tbody></table><h3 id="忽略大小写-Case-Insensitive"><a href="#忽略大小写-Case-Insensitive" class="headerlink" title="忽略大小写 (Case Insensitive)"></a>忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写.<br>例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索.</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="noopener">在线练习</a></p><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="全局搜索-Global-search"><a href="#全局搜索-Global-search" class="headerlink" title="全局搜索 (Global search)"></a>全局搜索 (Global search)</h3><p>修饰符 <code>g</code> 常用语执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).<br>例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p><pre>"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="noopener">在线练习</a></p><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="多行修饰符-Multiline"><a href="#多行修饰符-Multiline" class="headerlink" title="多行修饰符 (Multiline)"></a>多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用语执行一个多行匹配.</p><p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p><p>例如, 表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> , 末尾可选除换行符外任意字符. 根据 <code>m</code> 修饰符, 现在表达式匹配每行的结尾.</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre>[在线练习](https://regex101.com/r/hoGMkP/1)<pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="noopener">在线练习</a></p><h3 id="贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><pre>"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre><p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="noopener">在线练习</a></p><p><pre><br>“/(.*?at)/“ =&gt; <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat.<br></pre><br><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="noopener">在线练习</a></p><p>本文拷贝于<a href="https://github.com/zeeshanu/learn-regex" target="_blank" rel="noopener"><strong>learn-regex</strong></a> 项目</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.&lt;br&gt;“Regular expression”这个词比较拗口, 我们常使用缩写的术语”regex”或”regexp”.&lt;br&gt;正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等.&lt;/p&gt;
&lt;p&gt;想象你正在写一个应用, 然后你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.&lt;br&gt;我们使用以下正则表达式来验证一个用户名:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/regexp-cn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以上的正则表达式可以接受 &lt;code&gt;john_doe&lt;/code&gt;, &lt;code&gt;jo-hn_doe&lt;/code&gt;, &lt;code&gt;john12_as&lt;/code&gt;.&lt;br&gt;但不匹配&lt;code&gt;Jo&lt;/code&gt;, 因为它包含了大写的字母而且太短了.&lt;/p&gt;
    
    </summary>
    
      <category term="正则表达式" scheme="http://iholo.me/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://iholo.me/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Aircrack-ng破解wifi密码</title>
    <link href="http://iholo.me/posts/9c06b015/"/>
    <id>http://iholo.me/posts/9c06b015/</id>
    <published>2018-08-04T19:48:54.000Z</published>
    <updated>2019-11-02T08:24:33.241Z</updated>
    
    <content type="html"><![CDATA[<p>早就想折腾下wifi破解了，所以最近收了一个TL-WN722N，拿到手之后马上就是干，关于wifi破解网上教程一大片，我写这个也主要是为了记录下瞎折腾的过程，写的比较简单。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li><a href="https://www.offensive-security.com/kali-linux-vm-vmware-virtualbox-hyperv-image-download/" target="_blank" rel="noopener">kali 虚拟机</a></li><li>TL-WN722N v1版本（<a href="http://www.freebuf.com/articles/wireless/140065.html" target="_blank" rel="noopener">可开启监听模式的无线网卡</a> )</li></ol><h3 id="Aircrack-ng介绍"><a href="#Aircrack-ng介绍" class="headerlink" title="Aircrack-ng介绍"></a>Aircrack-ng介绍</h3><p>​    <a href="https://www.aircrack-ng.org/" target="_blank" rel="noopener">Aircrack-ng</a> (是无线渗透的利器,主要功能有：网络侦测，数据包嗅探，WEP和WPA/WPA2-PSK破解,其可以工作在任何支持监听模式的无线网卡上并嗅探802.11a，802.11b，802.11g的数据。该程序可运行在Linux和Windows上。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>aircrack-ng</td><td>破解WEP以及WPA（字典攻击）密钥</td></tr><tr><td>airdecap-ng</td><td>通过已知密钥来解密WEP或WPA嗅探数据</td></tr><tr><td>airmon-ng</td><td>将网卡设定为监听模式</td></tr><tr><td>aireplay-ng</td><td>数据包注入工具（Linux和Windows使用CommView驱动程序）</td></tr><tr><td>airodump-ng</td><td>数据包嗅探：将无线网络数据输送到PCAP或IVS文件并显示网络信息</td></tr><tr><td>airtun-ng</td><td>创建虚拟管道</td></tr><tr><td>airolib-ng</td><td>保存、管理ESSID密码列表</td></tr><tr><td>packetforge-ng</td><td>创建数据包注入用的加密包。</td></tr><tr><td>Tools</td><td>混合、转换工具</td></tr><tr><td>airbase-ng</td><td>软件模拟AP</td></tr><tr><td>airdecloak-ng</td><td>消除pcap文件中的WEP加密</td></tr><tr><td>airdriver-ng</td><td>无线设备驱动管理工具</td></tr><tr><td>airolib-ng</td><td>保存、管理ESSID密码列表，计算对应的密钥</td></tr><tr><td>airserv-ng</td><td>允许不同的进程访问无线网卡</td></tr><tr><td>buddy-ng</td><td>easside-ng的文件描述</td></tr><tr><td>easside-ng</td><td>和AP接入点通讯（无WEP）</td></tr><tr><td>tkiptun-ng</td><td>WPA/TKIP攻击</td></tr><tr><td>wesside-ng</td><td>自动破解WEP密钥</td></tr></tbody></table><h3 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h3><h4 id="airodump-ng-命令"><a href="#airodump-ng-命令" class="headerlink" title="airodump-ng 命令"></a><a href="https://www.aircrack-ng.org/doku.php?id=airodump-ng" target="_blank" rel="noopener">airodump-ng </a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">usage: airodump-ng &lt;options&gt; &lt;interface&gt;[,&lt;interface&gt;,...]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    --ivs                 : Save only captured IVs</span><br><span class="line">    --gpsd                : Use GPSd</span><br><span class="line">    --write      &lt;prefix&gt; : Dump file prefix</span><br><span class="line">    -w                    : same as --write</span><br><span class="line">    --beacons             : Record all beacons <span class="keyword">in</span> dump file</span><br><span class="line">    --update       &lt;secs&gt; : Display update delay <span class="keyword">in</span> seconds</span><br><span class="line">    --showack             : Prints ack/cts/rts statistics</span><br><span class="line">    -h                    : Hides known stations <span class="keyword">for</span> --showack</span><br><span class="line">    -f            &lt;msecs&gt; : Time <span class="keyword">in</span> ms between hopping channels</span><br><span class="line">    --berlin       &lt;secs&gt; : Time before removing the AP/client</span><br><span class="line">                            from the screen when no more packets</span><br><span class="line">                            are received (Default: 120 seconds)</span><br><span class="line">    -r             &lt;file&gt; : Read packets from that file</span><br><span class="line">    -x            &lt;msecs&gt; : Active Scanning Simulation</span><br><span class="line">    --manufacturer        : Display manufacturer from IEEE OUI list</span><br><span class="line">    --uptime              : Display AP Uptime from Beacon Timestamp</span><br><span class="line">    --wps                 : Display WPS information (<span class="keyword">if</span> any)</span><br><span class="line">    --output-format</span><br><span class="line">                &lt;formats&gt; : Output format. Possible values:</span><br><span class="line">                            pcap, ivs, csv, gps, kismet, netxml</span><br><span class="line">                            Short format <span class="string">"-o"</span></span><br><span class="line">                            The option can be specified multiple <span class="built_in">times</span>.  In this <span class="keyword">case</span>, each file format</span><br><span class="line">                            specified will be output.  Only ivs or pcap can be used, not both.  </span><br><span class="line">    --ignore-negative-one : Removes the message that says</span><br><span class="line">                            fixed channel &lt;interface&gt;: -1</span><br><span class="line">    --write-interval</span><br><span class="line">                &lt;seconds&gt; : Output file(s) write interval <span class="keyword">in</span> seconds</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Filter options:</span><br><span class="line">    --encrypt   &lt;suite&gt;   : Filter APs by cipher suite</span><br><span class="line">    --netmask &lt;netmask&gt;   : Filter APs by mask</span><br><span class="line">    --bssid     &lt;bssid&gt;   : Filter APs by BSSID</span><br><span class="line">    --essid     &lt;essid&gt;   : Filter APs by ESSID</span><br><span class="line">    --essid-regex &lt;regex&gt; : Filter APs by ESSID using a regular</span><br><span class="line">                            expression</span><br><span class="line">    -a                    : Filter unassociated clients</span><br><span class="line"></span><br><span class="line">By default, airodump-ng hop on 2.4GHz channels.</span><br><span class="line">You can make it capture on other/specific channel(s) by using:</span><br><span class="line">    --ht20                : Set channel to HT20 (802.11n)</span><br><span class="line">    --ht40-               : Set channel to HT40- (802.11n)</span><br><span class="line">    --ht40+               : Set channel to HT40+ (802.11n)</span><br><span class="line">    --channel &lt;channels&gt;  : Capture on specific channels</span><br><span class="line">    --band &lt;abg&gt;          : Band on <span class="built_in">which</span> airodump-ng should hop</span><br><span class="line">    -C    &lt;frequencies&gt;   : Uses these frequencies <span class="keyword">in</span> MHz to hop</span><br><span class="line">    --cswitch  &lt;method&gt;   : Set channel switching method</span><br><span class="line">                  0       : FIFO (default)</span><br><span class="line">                  1       : Round Robin</span><br><span class="line">                  2       : Hop on last</span><br><span class="line">    -s                    : same as --cswitch</span><br><span class="line"></span><br><span class="line">    --<span class="built_in">help</span>                : Displays this usage screen</span><br></pre></td></tr></table></figure><h4 id="aircrack-ng命令"><a href="#aircrack-ng命令" class="headerlink" title="aircrack-ng命令"></a><a href="https://www.aircrack-ng.org/doku.php?id=aircrack-ng" target="_blank" rel="noopener">aircrack-ng</a>命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aircrack-ng [options] &lt;capture file(s)&gt;</span><br></pre></td></tr></table></figure><p>Common options</p><table><thead><tr><th>Option</th><th>Param.</th><th>Description</th></tr></thead><tbody><tr><td>-a</td><td>amode</td><td>Force attack mode (1 = static WEP, 2 = WPA/WPA2-PSK)</td></tr><tr><td>-e</td><td>essid</td><td>If set, all IVs from networks with the same ESSID will be used. This option is also required for WPA/WPA2-PSK cracking if the ESSID is not broadcasted (hidden)</td></tr><tr><td>-b</td><td>bssid</td><td>Long version -<code></code>-bssid. Select the target network based on the access point’s MAC address</td></tr><tr><td>-p</td><td>nbcpu</td><td>On SMP systems: # of CPU to use. This option is invalid on non-SMP systems</td></tr><tr><td>-q</td><td><em>none</em></td><td>Enable quiet mode (no status output until the key is found, or not)</td></tr><tr><td>-C</td><td>MACs</td><td>Long version -<code></code>-combine. Merge the given APs (separated by a comma) into virtual one</td></tr><tr><td>-l</td><td>file name</td><td>(Lowercase L, ell) logs the key to the file specified. Overwrites the file if it already exists</td></tr></tbody></table><p>Static WEP cracking options</p><table><thead><tr><th>Option</th><th>Param.</th><th>Description</th></tr></thead><tbody><tr><td>-c</td><td><em>none</em></td><td>Restrict the search space to alpha-numeric characters only (0x20 - 0x7F)</td></tr><tr><td>-t</td><td><em>none</em></td><td>Restrict the search space to binary coded decimal hex characters</td></tr><tr><td>-h</td><td><em>none</em></td><td>Restrict the search space to numeric characters (0x30-0x39) These keys are used by default in most Fritz!BOXes</td></tr><tr><td>-d</td><td>start</td><td>Long version -<code></code>-debug. Set the beginning of the WEP key (in hex), for debugging purposes</td></tr><tr><td>-m</td><td>maddr</td><td>MAC address to filter WEP data packets. Alternatively, specify -m ff:ff:ff:ff:ff:ff to use all and every IVs, regardless of the network</td></tr><tr><td>-n</td><td>nbits</td><td>Specify the length of the key: 64 for 40-bit WEP, 128 for 104-bit WEP, etc. The default value is 128</td></tr><tr><td>-i</td><td>index</td><td>Only keep the IVs that have this key index (1 to 4). The default behaviour is to ignore the key index</td></tr><tr><td>-f</td><td>fudge</td><td>By default, this parameter is set to 2 for 104-bit WEP and to 5 for 40-bit WEP. Specify a higher value to increase the bruteforce level: cracking will take more time, but with a higher likelyhood of success</td></tr><tr><td>-k</td><td>korek</td><td>There are 17 korek statistical attacks. Sometimes one attack creates a huge false positive that prevents the key from being found, even with lots of IVs. Try -k 1, -k 2, … -k 17 to disable each attack selectively</td></tr><tr><td>-x/-x0</td><td><em>none</em></td><td>Disable last keybytes brutforce</td></tr><tr><td>-x1</td><td><em>none</em></td><td>Enable last keybyte bruteforcing (default)</td></tr><tr><td>-x2</td><td><em>none</em></td><td>Enable last two keybytes bruteforcing</td></tr><tr><td>-X</td><td><em>none</em></td><td>Disable bruteforce multithreading (SMP only)</td></tr><tr><td>-s</td><td><em>none</em></td><td>Show the key in ASCII while cracking</td></tr><tr><td>-y</td><td><em>none</em></td><td>Experimental single bruteforce attack which should only be used when the standard attack mode fails with more than one million IVs</td></tr><tr><td>-z</td><td><em>none</em></td><td>Invokes the PTW WEP cracking method (Default in v1.x)</td></tr><tr><td>-P</td><td>number</td><td>Long version -<code></code>-ptw-debug. Invokes the PTW debug mode: 1 Disable klein, 2 PTW.</td></tr><tr><td>-K</td><td><em>none</em></td><td>Invokes the Korek WEP cracking method. (Default in v0.x)</td></tr><tr><td>-D</td><td><em>none</em></td><td>Long version -<code></code>-wep-decloak. Run in WEP decloak mode</td></tr><tr><td>-1</td><td><em>none</em></td><td>Long version -<code></code>-oneshot. Run only 1 try to crack key with PTW</td></tr><tr><td>-M</td><td>number</td><td>(WEP cracking) Specify the maximum number of IVs to use</td></tr><tr><td>-V</td><td><em>none</em></td><td>Long version -<code></code>-visual-inspection. Run in visual inspection mode (only with KoreK)</td></tr></tbody></table><p>WEP and WPA-PSK cracking options</p><table><thead><tr><th>Option</th><th>Param.</th><th>Description</th></tr></thead><tbody><tr><td>-w</td><td>words</td><td>Path to a wordlists or “-” without the quotes for standard in (stdin). Separate multiple wordlists by comma</td></tr><tr><td>-N</td><td>file</td><td>Create a new cracking session and save it to the specified file</td></tr><tr><td>-R</td><td>file</td><td>Restore cracking session from the specified file</td></tr></tbody></table><p>WPA-PSK options</p><table><thead><tr><th>Option</th><th>Param.</th><th>Description</th></tr></thead><tbody><tr><td>-E</td><td>file&gt;</td><td>Create EWSA Project file v3</td></tr><tr><td>-j</td><td>file</td><td>Create Hashcat v3.6+ Capture file (HCCAPX)</td></tr><tr><td>-J</td><td>file</td><td>Create Hashcat Capture file</td></tr><tr><td>-S</td><td><em>none</em></td><td>WPA cracking speed test</td></tr><tr><td>-Z</td><td>sec</td><td>WPA cracking speed test execution length in seconds</td></tr><tr><td>-r</td><td>database</td><td>Utilizes a database generated by <a href="https://www.aircrack-ng.org/doku.php?id=airolib-ng" target="_blank" rel="noopener">airolib-ng</a> as input to determine the WPA key. Outputs an error message if aircrack-ng has not been compiled with sqlite support</td></tr></tbody></table><p>SIMD Selection</p><table><thead><tr><th>Option</th><th>Param.</th><th>Description</th></tr></thead><tbody><tr><td>-<code></code>-simd</td><td>optimization</td><td>Use user-specified SIMD optimization instead of the fastest one</td></tr><tr><td>-<code></code>-simd-list</td><td><em>none</em></td><td>Shows a list of the SIMD optimizations available</td></tr></tbody></table><p>Other options</p><table><thead><tr><th>Option</th><th>Param.</th><th>Description</th></tr></thead><tbody><tr><td>-H</td><td><em>none</em></td><td>Long version -<code></code>-help. Output help information</td></tr><tr><td>-u</td><td><em>none</em></td><td>Long form -<code></code>-cpu-detect. Provide information on the number of CPUs and features available such as MMX, SSE2, AVX, AVX2, AVX512</td></tr></tbody></table><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>1.加载usb无线网卡并开启监听模式</p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxux376pkj20k204g76r.jpg" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig wlan0 up</span><br><span class="line">sudo airmon-ng start wlan0</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxuxeiuorj20mu0adq9o.jpg" alt="screenshot_20180804_170955"></p><p>可以看到已经开启了监听模式，输入以下命令也可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iwconfig</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxuwvceq7j20mw05c41r.jpg" alt=""></p><p>2.查看周边wifi情况,选择目标wifi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo airodumo-ng wlan0mon</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxuxzbfxpj20mr0dptj7.jpg" alt=""></p><h2 id="抓取"><a href="#抓取" class="headerlink" title="抓取"></a>抓取</h2><p>现在开始抓握手包，以上图第一个WIFI(YXGY41403)为目标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo airodump-ng --ignore-negative-one -w ./403.cap -c 10 --bssid 00:4B:F3:15:3D:D0 wlan0mon</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxuwpsnt1j20sz017gmf.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxuxrbjz1j20mm069wi4.jpg" alt=""></p><p>可以看到已经在监听了，为了顺利抓到握手包，我们需要使用DEAUTH攻击使已经连接的客户端断开并重新连接，以产生握手包。（注意：抓握手包破解必须有合法的客户端才行）攻击命令如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aireplay-ng -0 11 -a 00:4B:F3:15:3D:D0 -x 100 wlan0mon</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxuxhzfsqj20lg0buq8q.jpg" alt=""></p><p>如果抓到握手包 界面会有提示 WPA handshake（如下图红色标识）此时可停止抓包。</p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxux049eoj20n905m0wa.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxuwxgm4gj20li024t9t.jpg" alt=""></p><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>抓包握手包之后，接着就是破解了，这个才是重点,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo aircrack-ng -w pass.txt 403-01.cap</span><br><span class="line">参数解释：-w 字典路径</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxv2ksg4sj20ll03uwge.jpg" alt=""></p><p>上图是pass.txt 内的密码，YXGY41403为正确的wifi密码,当使用aircrack-ng执行暴力破解后,可看到密码被找到了</p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxv3xtm05j20lo0c045z.jpg" alt=""></p><p>这里只是为了演示，其实暴力破解是非常费时费力的,花了大力气，如果密码不在字典内，多久都是白费，所以要尽可能的想到与目标wifi相关联的信息，比如门牌号,手机号码,姓名等信息去生成字典，缩小密码的范围，不然只能换种方法或者放弃了。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><h3 id="EWSA-WPA无线密码破解利器"><a href="#EWSA-WPA无线密码破解利器" class="headerlink" title="EWSA  WPA无线密码破解利器"></a><a href="https://www.elcomsoft.com/ewsa.html" target="_blank" rel="noopener">EWSA</a>  WPA无线密码破解利器</h3><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxv3bdm4gj20p10eogm8.jpg" alt=""></p><h3 id="HashCat-GPU破解神器"><a href="#HashCat-GPU破解神器" class="headerlink" title="HashCat  GPU破解神器"></a><a href="https://hashcat.net/hashcat/" target="_blank" rel="noopener">HashCat</a>  GPU破解神器</h3><h3 id="GpuHash-在线破解"><a href="#GpuHash-在线破解" class="headerlink" title="GpuHash 在线破解"></a>GpuHash 在线破解</h3><p><a href="https://gpuhash.me/" target="_blank" rel="noopener">https://gpuhash.me/</a>     收费</p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxv3ptuqqj20h90b0tgs.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxv44nj4tj20hb08vdmt.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/7bf9f3e8gy1ftxv3q7y6dj20hs0bbq89.jpg" alt=""></p><blockquote><p><a href="http://www.freebuf.com/articles/wireless/58342.html" target="_blank" rel="noopener">WPA-PSK无线网络破解原理及过程</a></p><p><a href="https://github.com/Xu-Jian/Wifi-Crack/blob/master/Wifi%E7%A0%B4%E8%A7%A3.rst" target="_blank" rel="noopener">Wifi破解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就想折腾下wifi破解了，所以最近收了一个TL-WN722N，拿到手之后马上就是干，关于wifi破解网上教程一大片，我写这个也主要是为了记录下瞎折腾的过程，写的比较简单。&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="http://iholo.me/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="无线安全" scheme="http://iholo.me/tags/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://iholo.me/posts/9a246216/"/>
    <id>http://iholo.me/posts/9a246216/</id>
    <published>2018-08-01T21:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。 例如RSS订阅，公众号推送。</p><a id="more"></a><p>这里使用Jdk内置提供的Observable和Observer来实现观察者模式，</p><p>首先一个定义一个Observable，仓库继承Observable，当仓库新增商品时，各电商平台同步商家更新商品信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreHouse</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; productList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StoreHouse instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StoreHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StoreHouse <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> StoreHouse();</span><br><span class="line">            instance.productList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productList.add(product);</span><br><span class="line">        System.out.println(<span class="string">"仓库新增产品:"</span> + product);</span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者实现Observer接口，并实现update方法</p><p>观察者1：京东电商平台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdPlatform</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        String productInfo = (String) arg;</span><br><span class="line">        System.out.println(<span class="string">"京东平台新增产品信息:"</span> + productInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者2:淘宝平台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoPlatform</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        String productInfo = (String) arg;</span><br><span class="line">        System.out.println(<span class="string">"新增淘宝产品信息"</span> + productInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当仓库新增产品，通知观察者更新</p><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String info = <span class="string">"Iphone BIG X"</span>;</span><br><span class="line">        StoreHouse storeHouse = StoreHouse.getInstance();</span><br><span class="line">        TaoPlatform taoPlatform = <span class="keyword">new</span> TaoPlatform();</span><br><span class="line">        JdPlatform jdPlatform = <span class="keyword">new</span> JdPlatform();</span><br><span class="line">        storeHouse.addObserver(taoPlatform);</span><br><span class="line">        storeHouse.addObserver(jdPlatform);</span><br><span class="line">        storeHouse.addProduct(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">仓库新增产品:Iphone BIG X</span><br><span class="line">京东平台新增产品信息:Iphone BIG X</span><br><span class="line">新增淘宝产品信息Iphone BIG X</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://www.importnew.com/15557.html" target="_blank" rel="noopener">观察者</a></p><p><a href="https://www.cnblogs.com/luohanguo/p/7825656.html" target="_blank" rel="noopener">Java设计模式之观察者模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。 例如RSS订阅，公众号推送。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://iholo.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://iholo.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jdk动态代理与CGLIB动态代理的简单应用</title>
    <link href="http://iholo.me/posts/4de03550/"/>
    <id>http://iholo.me/posts/4de03550/</id>
    <published>2018-08-01T20:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>动态代理应用广泛，代理对象的意义在于代理真实对象来控制对象的访问，以前基础不扎实，故而重读旧书，望有新的感悟，以下作为笔记，方便日后查看 </p><a id="more"></a><h2 id="Jdk动态代理"><a href="#Jdk动态代理" class="headerlink" title="Jdk动态代理"></a>Jdk动态代理</h2><p>JDK代理必须借助接口才能产生对象，并且代理对象要实现InvocationHandler接口</p><p>首先定义接口，之后提供接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHell</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"THE WORLD"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"display"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要进行代理，首先要建立起代理对象与真实服务对象的关系，然后再实现代理逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandle</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target=<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立代理对象与真实对象的关系</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 被代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 当前对象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--执行真实服务前--"</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"--执行真实服务后--"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过bind() 返回代理对象,Proxy.newProxyInstance 方法参数说明如下:</p><ol><li>第一个参数是类加载器</li><li>被代理的接口</li><li>实现方法逻辑的代理类(需实现InvocationHandler接口的invoke方法)</li></ol><p>之后在invoke方法中实现具体的代理逻辑,其参数说明如下:</p><ol><li>proxy:代理对象</li><li>method：当前调度方法</li><li>args:方法参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JdkProxyHandler jdkProxyHandler=<span class="keyword">new</span> JdkProxyHandler();</span><br><span class="line">IUserService userService = (IUserService) jdkProxyHandler.bind(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">userService.sayHello();</span><br></pre></td></tr></table></figure><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>CGLIB代理只需要提供一个非抽象类即可生成代理</p><p>引入相关的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib-nodep --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodep<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用增强类对象生成代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target Class类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Class类的CGLIB代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//CGLIB enhance 增强类型对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置增强类型</span></span><br><span class="line">        enhancer.setSuperclass(target);</span><br><span class="line">        <span class="comment">//定义代理逻辑对象</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//生成并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy       代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      当前调用方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理逻辑返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行真实服务前"</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"执行真实服务后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CglibProxy cglibProxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">IUserService userService = (IUserService) cglibProxy.getProxy(UserServiceImpl.class);</span><br><span class="line">userService.sayHello();</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>一般情况下会设计拦截器接口，而且底层的动态代理屏蔽，调用者只要知道拦截器接口即可,实现拦截器逻辑，首先定义拦截器接口，之后通过代理对象绑定真实对象及拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否反射真实对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 对象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现拦截器接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取代原方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成拦截器对象,建立代理对象与真实对象，拦截器之间的关系，并实现代理逻辑,这样就实现了一个拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyHandle</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器 全限定类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interceptorClassName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxyHandle</span><span class="params">(Object target, String interceptorClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.interceptorClassName = interceptorClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定并返回代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 真实对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interceptorClassName  拦截器 全限定类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target, String interceptorClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> JdkProxyHandle(target, interceptorClassName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  调用方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptorClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        Interceptor interceptor = (Interceptor) Class.forName(interceptorClassName).newInstance();</span><br><span class="line">        <span class="keyword">if</span> (interceptor.before(proxy, target, method, args)) &#123;</span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interceptor.around(proxy, target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        interceptor.after(proxy, target, method, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IUserService userService= (IUserService) JdkProxyHandle.getProxy(<span class="keyword">new</span> UserServiceImpl(), CustomInterceptor.class.getName());</span><br><span class="line">userService.sayHello();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态代理应用广泛，代理对象的意义在于代理真实对象来控制对象的访问，以前基础不扎实，故而重读旧书，望有新的感悟，以下作为笔记，方便日后查看 &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://iholo.me/categories/Java/"/>
    
    
      <category term="Java" scheme="http://iholo.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://iholo.me/posts/f1601c3e/"/>
    <id>http://iholo.me/posts/f1601c3e/</id>
    <published>2018-07-31T20:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是设计模式中最简单的一种,但是其种类很多，适用场景也不同,以下为7种单例模式的写法,各有优势。</p><a id="more"></a><h2 id="单例的特点"><a href="#单例的特点" class="headerlink" title="单例的特点"></a>单例的特点</h2><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例</li></ol><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉模式的核心就是懒加载。启动速度快、节省资源，一直到实例被第一次访问，才需要初始化单例。</p><h3 id="懒汉模式（线程安全-synchronized-同步"><a href="#懒汉模式（线程安全-synchronized-同步" class="headerlink" title="懒汉模式（线程安全-synchronized 同步)"></a>懒汉模式（线程安全-synchronized 同步)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该模式线程安全，但是使用synchronized 后效率急剧下降，才不考虑性能的情况下可以采用。</p><h3 id="懒汉模式（线程不安全-DCL-）"><a href="#懒汉模式（线程不安全-DCL-）" class="headerlink" title="懒汉模式（线程不安全-DCL ）"></a>懒汉模式（线程不安全-DCL ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该模式检查两次 ，即所谓“双重检查锁”（Double Check Lock，简称DCL ）仍无法保证线程安全。</p><h3 id="懒汉模式（线程安全-volatile-amp-DCL-）"><a href="#懒汉模式（线程安全-volatile-amp-DCL-）" class="headerlink" title="懒汉模式（线程安全-volatile&amp;DCL ）"></a>懒汉模式（线程安全-volatile&amp;DCL ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 该模式使用volatile关键字, 并采用DCL ,线程安全，但是仍有办法破坏单例。</p><h2 id="饿汉模式-线程安全"><a href="#饿汉模式-线程安全" class="headerlink" title="饿汉模式(线程安全)"></a>饿汉模式(线程安全)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉模式在类加载时初始化单例，以后访问时直接返回即可。</p><h2 id="Holder模式（线程安全）"><a href="#Holder模式（线程安全）" class="headerlink" title="Holder模式（线程安全）"></a>Holder模式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SingletonHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instane = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instane;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是静态变量，足够方便和线程安全；通过静态的Holder类持有真正实例，间接实现了懒加载 ，建议使用。</p><h2 id="枚举模式"><a href="#枚举模式" class="headerlink" title="枚举模式"></a>枚举模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 </p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><table><thead><tr><th>实现方式</th><th>关键点</th><th>资源浪费</th><th>线程安全</th><th>性能足够优化</th></tr></thead><tbody><tr><td>懒汉</td><td>懒加载</td><td>否</td><td>否</td><td>-</td></tr><tr><td>懒汉-synchronized</td><td>懒加载、同步</td><td>否</td><td>是</td><td>否</td></tr><tr><td>懒汉-DCL</td><td>懒加载、DCL</td><td>否</td><td>否</td><td>-</td></tr><tr><td>懒汉-volatile&amp;DCL</td><td>懒加载、DCL、volatile</td><td>否</td><td>是</td><td>是</td></tr><tr><td>饿汉</td><td>静态变量初始化</td><td>是</td><td>是</td><td>是</td></tr><tr><td>Holder(静态内部类)</td><td>静态变量初始化、holder</td><td>否</td><td>是</td><td>是</td></tr><tr><td>枚举</td><td>枚举本质、静态变量初始化</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><blockquote><p><a href="http://cantellow.iteye.com/blog/838473" target="_blank" rel="noopener">单例模式的7种写法</a></p><p><a href="https://monkeysayhi.github.io/2017/09/27/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/" target="_blank" rel="noopener">面试中单例模式有几种写法</a></p><p><a href="http://www.importnew.com/28461.html" target="_blank" rel="noopener">互斥同步、锁优化及synchronized和volatile</a></p><p><a href="http://www.importnew.com/27863.html" target="_blank" rel="noopener">面试必问的 volatile，你了解多少？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是设计模式中最简单的一种,但是其种类很多，适用场景也不同,以下为7种单例模式的写法,各有优势。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://iholo.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://iholo.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://iholo.me/posts/ff8068c0/"/>
    <id>http://iholo.me/posts/ff8068c0/</id>
    <published>2018-07-30T20:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p><p>该方法的基本思想是：</p><ol><li>先从数列中取出一个数作为基准数。</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>再对左右区间重复第二步，直到各区间只有一个数。<br>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：<a id="more"></a>先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。<br>以一个数组作为示例，取区间第一个数为基准数。</li></ol><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>==<em>72 </em>==</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>48</td><td>85</td></tr></tbody></table><p>初始时，i = 0;  j = 9;   X = a[i] = 72</p><p>由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。</p><p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>==<em>48 </em>==</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table><p> i = 3;   j = 7;   X=72</p><p>再重复上面的步骤，先从后向前找，再从前向后找。</p><p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p><p>从i开始向后找，当i=5时，由于i==j退出。</p><p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p><p>数组变为：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>==<em>48 </em>==</td><td>6</td><td>57</td><td>42</td><td>60</td><td>72</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。</p><p>对挖坑填数进行总结</p><ol><li>i =L; j = R; 将基准数挖出形成第一个坑a[i]。</li><li>j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</li><li>i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</li><li>再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</li></ol><p>照着这个总结很容易实现挖坑填数的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = AdjustArray(s, l, r);<span class="comment">//先成挖坑填数法调整s[]</span></span><br><span class="line">        quick_sort1(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">        quick_sort1(s, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再写分治法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = AdjustArray(s, l, r);<span class="comment">//先成挖坑填数法调整s[]</span></span><br><span class="line">        quick_sort1(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">        quick_sort1(s, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的代码显然不够简洁，对其组合整理下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = AdjustArray(s, l, r);<span class="comment">//先成挖坑填数法调整s[]</span></span><br><span class="line">        quick_sort1(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">        quick_sort1(s, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。&lt;/p&gt;
&lt;p&gt;该方法的基本思想是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先从数列中取出一个数作为基准数。&lt;/li&gt;
&lt;li&gt;分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。&lt;/li&gt;
&lt;li&gt;再对左右区间重复第二步，直到各区间只有一个数。&lt;br&gt;虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：
    
    </summary>
    
      <category term="数据结构" scheme="http://iholo.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="http://iholo.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>系统管理与维护命令</title>
    <link href="http://iholo.me/posts/10442c61/"/>
    <id>http://iholo.me/posts/10442c61/</id>
    <published>2018-03-20T22:35:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="uname命令"><a href="#uname命令" class="headerlink" title="uname命令"></a>uname命令</h2><p>uname命令用来显示操作系统信息,比如CPU类型，主机名，内核版本</p><p>命令格式:<code>uname [选项]</code></p><a id="more"></a><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">打印操作系统全部信息</td></tr><tr><td style="text-align:center">-s</td><td style="text-align:center">显示操作系统类型  eg:Linux</td></tr><tr><td style="text-align:center">-n</td><td style="text-align:center">显示主机名</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">显示内核版本 eg:4.4.0-117-generic</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">内核版本时间</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:center">显示系统CPU类型 32位or64位 eg:x86_64</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">显示处理器类型 同上</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">打印操作系统 eg:GNU/Linux</td></tr></tbody></table><p>开启BBR，需要更换内核版本，用的比较多，但一直没有认真的了解过，因而记录下来。</p><h2 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h2><p>列出截止到现在登入系统的用户相关信息,当执行last命令时，默认读取位于/var/log 目录下名称为wtmp的文件并显示出来</p><p><code>last [选项] [-n 显示列数]</code></p><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td>把从何处登入系统的主机名或ip地址显示在最后一行</td></tr><tr><td style="text-align:center">-R</td><td>不显示登入系统的主机名称或ip地址</td></tr><tr><td style="text-align:center">-x</td><td>显示关机，重启以及执行等级变化信息</td></tr><tr><td style="text-align:center">-n &lt;显示列数&gt; or -&lt;显示列数&gt;</td><td>显示的列数</td></tr><tr><td style="text-align:center">-d</td><td>将显示的IP地址转换成主机名称</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;uname命令&quot;&gt;&lt;a href=&quot;#uname命令&quot; class=&quot;headerlink&quot; title=&quot;uname命令&quot;&gt;&lt;/a&gt;uname命令&lt;/h2&gt;&lt;p&gt;uname命令用来显示操作系统信息,比如CPU类型，主机名，内核版本&lt;/p&gt;
&lt;p&gt;命令格式:&lt;code&gt;uname [选项]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://iholo.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://iholo.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ls命令详解</title>
    <link href="http://iholo.me/posts/10442c60/"/>
    <id>http://iholo.me/posts/10442c60/</id>
    <published>2018-03-20T20:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输出信息详解"><a href="#输出信息详解" class="headerlink" title="输出信息详解"></a>输出信息详解</h2><p><strong>ls命令</strong>用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件</p><p><img src="/images/7bf9f3e8gy1fpji0oe5lhj20e80363ye.jpg" alt=""></p><a id="more"></a><p>以第一条信息为例 <code>-rw-r--r-- 1 root root 1.6K Jul 15  2017 config.json</code></p><p>第一个字符:  <code>-</code></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">d</td><td style="text-align:center">此项为目录</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">此项为块特殊文件</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">此项为字符特殊文件</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">此项为符号链接</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">此项为一个先进先出（FIFO）特殊文件</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">此项为本地套接字</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">此项为普通文件</td></tr></tbody></table><p>权限 : <code>rw-r--r--每三个一组分别对应文件所有者权限，同组用户权限，其他用户权限</code></p><table><thead><tr><th>参数</th><th style="text-align:center">对应的数字权限</th><th>权限说明</th></tr></thead><tbody><tr><td>r</td><td style="text-align:center">4</td><td>读</td></tr><tr><td>w</td><td style="text-align:center">2</td><td>写（编辑）</td></tr><tr><td>x</td><td style="text-align:center">1</td><td>执行（搜索</td></tr><tr><td>-</td><td style="text-align:center">0</td><td>没有授予相应的许可权</td></tr></tbody></table><p>文件硬链接数或目录子目录数:<code>1</code><br>所有者:<code>root</code><br>所有者所在的组:<code>root</code><br>文件大小:<code>1.6k</code><br>文件创建时间:<code>Jul 15  2017</code><br>文件名:<code>config.json 如果是一个符号链接,那么会有一个 &quot;-&gt;&quot; 箭头符号,后面根一个它指向的文件名.</code></p><h2 id="ls命令详解"><a href="#ls命令详解" class="headerlink" title="ls命令详解"></a>ls命令详解</h2><p><code>ls  [选项][路径或文件名]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-a --all 列出目录下的所有文件，包括隐藏文件</span><br><span class="line">-A --almost-all 列出除<span class="string">"."</span>(表示当前目录)和<span class="string">".."</span>(表示当前目录的父目录)的所有文件</span><br><span class="line">--author 显示文件所有者</span><br><span class="line">-b --escape 以八进制（\nnn）表示法显示非打印字符</span><br><span class="line">--block-size=size   规定块的大小，显示以该文件实际占据的块数量,eg:--block-size=m 以M（兆）为单位显示</span><br><span class="line">-B, --ignore-backups 不列出以备份字尾字符串<span class="string">"~"</span>结尾的文件</span><br><span class="line">-c  结合 -lt 按文件最后修改时间排序，结合 -l 按最后修改时间和名称排序</span><br><span class="line">-C 多列显示输出结果</span><br><span class="line">--color=[when] 使用不同的颜色高亮显示不同类型的,when可以是 <span class="string">"always"</span>(默认),<span class="string">"never"</span>，<span class="string">"auto"</span></span><br><span class="line">-d, --directory 仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表</span><br><span class="line">-D, --dired</span><br><span class="line">-f 该参数关闭 -l、-t、-s 和 -r 标志并且开启 -a 标志，列表的顺序就是项出现在目录中的顺序。</span><br><span class="line">-F 如果文件是目录，在文件名后面放置一个 /（斜杠），如果文件可执行，那么放置一个 *（星号），如果文件为套接字，那么放置一个 =（等号），如果为 FIFO，那么放置一个 |（管道）符号，如果是符号链接，那么放置一个 @。除非指定了 -H 或 -L 标志，否则不允许使用命名为操作数的符号链接。</span><br><span class="line">--full-time 显示完整的时间， 结合 --time-style 使用规定时间格式。</span><br><span class="line">-g 与使用 -l 标志时显示同样的信息，但不会显示所有者和符号链接信息。 </span><br><span class="line">-G, --no-group  不显示所属的组名称</span><br><span class="line">-h, --human-readable 以人类可读的形式，显示文件大小</span><br><span class="line">-I, --ignore=PATTERN 不显示满足条件的文件或目录 eg: ls -l -I *.json 不列出json文件</span><br><span class="line">-l  显示详细信息</span><br><span class="line">-L列示链接引用的文件或目录内容。这是缺省操作。后跟符号链接。如果使用 -l 选项，-N 选项就成为缺省值，不后跟符号链接。当使用 -l 选项时，仅有 -L 选项能够覆盖 -N 缺省值。</span><br><span class="line">-m  横向显示并以逗号分隔</span><br><span class="line">-n, --numeric-uid-gid 和 -l 效果一样，但是以数字的形式列出用户和用户所属组的ID</span><br><span class="line">-N当确定文件状态时，不跟在符号链接之后。注：如果使用 -L 和 -N 两个标志，最后一个标志起作用。同样的，任何时候给定 一个包含以 /（斜杠）作为最后字符的符号链接，不管使用何种选项，后面都会跟有链接。</span><br><span class="line">-o 同 -l 但不显示所属组信息</span><br><span class="line">-p, --indicator-style=slash 如果文件是目录，在每个文件名后面放置一个斜杠</span><br><span class="line">-q 用<span class="string">"?"</span> 代替不可输出的字符</span><br><span class="line">-Q 把输出的文件名用双引号括起来</span><br><span class="line">-r 对目录反向排序</span><br><span class="line">-R 列出所有子目录下的文件</span><br><span class="line">-s 在每个文件名后面输入该文件的大小</span><br><span class="line">--sort=WORD 可选的排序类型 none (-U), size (-S), time (-t), version (-v), extension (-X)</span><br><span class="line">-t 以时间排序</span><br><span class="line">-u 使用最近访问时间，而不是最近修改时间用以排序（当使用 -t 参数）或者显示（当使用 -l 参数）。如果不和 -t 或 -l 标志或两者配合使用，那么该参数无效。</span><br><span class="line">-U 显示与 -l 标志相似的信息</span><br><span class="line">-v 自然排序按照版本号</span><br><span class="line">-x 按列输出，很想排序</span><br><span class="line">-X 按字母排序</span><br></pre></td></tr></table></figure><p>以上内容只是为了方便以后查看，如整理的有问题，还请留言指正😄 🤝 🤩 👀 </p><p>参考:</p><blockquote><p><a href="https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_71/com.ibm.aix.cmds3/ls.htm" target="_blank" rel="noopener">ls命令</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;输出信息详解&quot;&gt;&lt;a href=&quot;#输出信息详解&quot; class=&quot;headerlink&quot; title=&quot;输出信息详解&quot;&gt;&lt;/a&gt;输出信息详解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ls命令&lt;/strong&gt;用来显示目标列表，在Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以分区不同类型的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/7bf9f3e8gy1fpji0oe5lhj20e80363ye.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://iholo.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://iholo.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu nfs服务安装与配置</title>
    <link href="http://iholo.me/posts/4a75285f/"/>
    <id>http://iholo.me/posts/4a75285f/</id>
    <published>2017-11-05T16:47:54.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>工作中恰好遇到了nfs共享文件目录的问题，以前也只是了解nfs服务，但没有实际安装与配置该服务，因而开始折腾的时候，问题很多，也查了很多资料。nfs服务安装配置很简单，问题不大，阻碍着我的是防火墙的配置，小白表示很无奈，这篇文章也是为了记录一下学习过程，方便日后查看。</p><a id="more"></a><h2 id="1-NFS服务介绍"><a href="#1-NFS服务介绍" class="headerlink" title="1.NFS服务介绍"></a>1.NFS服务介绍</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">网络文件系统</a>（英语：Network File System，缩写作 NFS）是一种分布式文件系统协议，最初由Sun Microsystems公司开发，并于1984年发布<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">1</a>。其功能旨在允许客户端主机可以像访问本地存储一样通过网络访问服务器端文件。</p></blockquote><p>NFS协议是基于开放网络运算远程过程调用（ONC RPC）协议之上的。它是一个开放、标准的RFC协议，任何人或组织都可以依据标准实现它。NFS协议有多个版本NFSv2,NFSv3,NFSv4，目前多使用后两种版本,NFS其目的也在于在不同硬件与操作系统之间进行文件的共享。</p><h2 id="2-Ubuntu-安装NFS服务"><a href="#2-Ubuntu-安装NFS服务" class="headerlink" title="2.Ubuntu 安装NFS服务"></a>2.Ubuntu 安装NFS服务</h2><p>一般情况下，系统都是默认安装好了NFS服务的，如果没有，在Ubuntu下可以安装nfs-kernel-server<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></p><p><img src="/images/7bf9f3e8gy1fktmq7s7hrj20et04ljrh.jpg" alt=""></p><p>安装完成后编辑配置文件 /etc/exports,在文件中针对NFSv2，NFSV3和NFSv4给出了不同的配置参数。<br>首先介绍NFSv2，NFSv3的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/data hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)</span><br></pre></td></tr></table></figure><ol><li><p>输出目录<br>输出目录是指NFS系统中需要共享给客户机使用的目录,如/mnt/data </p></li><li><p>客户端<br>客户端是指网络中可以访问这个NFS输出目录的计算机<br>以下为常用方式<br>指定ip地址的主机：<figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定子网中的所有主机：``` 192.168.0.0/24 192.168.0.0/255.255.255.0</span><br></pre></td></tr></table></figure></p><p>指定域名的主机：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定域中的所有主机：```*.bsmart.cn</span><br></pre></td></tr></table></figure></p><p>所有主机：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 3.  选项：</span><br><span class="line">选项用来设置输出目录的访问权限、用户映射等。</span><br><span class="line">NFS主要有3类选项：</span><br><span class="line">访问权限选项</span><br></pre></td></tr></table></figure></p></li></ol><p>设置输出目录只读：ro<br>设置输出目录读写：rw<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户映射选项</span><br></pre></td></tr></table></figure></p><p>all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）；<br>no_all_squash：与all_squash取反（默认设置）；<br>root_squash：将root用户及所属组都映射为匿名用户或用户组（默认设置）；<br>no_root_squash：与rootsquash取反；<br>anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）；<br>anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）；<br>其它选项<br>secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）；<br>insecure：允许客户端从大于1024的tcp/ip端口连接服务器；<br>sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性；<br>async：将数据先保存在内存缓冲区中，必要时才写入磁盘；<br>wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）；<br>no_wdelay：若有写操作则立即执行，应与sync配合使用；<br>subtree：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限(默认设置)；<br>no_subtree：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建文件夹</span><br><span class="line">```Shell &#123;.line-numbers&#125;</span><br><span class="line">mkdir -p /mnt/share</span><br></pre></td></tr></table></figure></p><p>修改/etc/exports配置文件内容<br><figure class="highlight shell"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/share  *(rw,sync,no_subtree_check)</span><br></pre></td></tr></table></figure></p><p>之后启动NFS服务,查看NFS服务状态<br><figure class="highlight shell"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service nfs-kernel-server start</span><br><span class="line">service nfs-kernel-server status</span><br></pre></td></tr></table></figure></p><p><img src="/images/7bf9f3e8gy1fl9n0k37esj20ls08edgg.jpg" alt=""><br>查看服务端开放共享的文件夹</p><figure class="highlight shell"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e</span><br></pre></td></tr></table></figure><p>现在NFS服务端已经配置成功了，开始在客户端上挂载，同样的先安装nfs服务<br><figure class="highlight shell"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e ip 显示服务端可挂载的文件目录</span><br></pre></td></tr></table></figure></p><p>客户端挂载目录<br><figure class="highlight shell"><figcaption><span>.&#123;line-numers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/data</span><br><span class="line">mount -t nfs 服务端ip:/mnt/share /mnt/data</span><br></pre></td></tr></table></figure></p><p>现在在服务端执行 showmount -a 可以查看已连接的客户端,为什么没有显示客户端情况呢?<br>客户端在运行的时候指定版本为NFSv3即可<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs -o nfsvers=3 服务端ip:/mnt/share /mnt/data</span><br></pre></td></tr></table></figure></p><p>现在再执行 showmount -a 即可显示客户端信息<br><img src="/images/7bf9f3e8gy1fl9n17po64j20eh01s0sk.jpg" alt=""></p><blockquote><ol><li><a href="http://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html" target="_blank" rel="noopener">Linux NFS服务器的安装与配置</a>  </li><li><a href="http://blog.csdn.net/u013814949/article/details/50511136" target="_blank" rel="noopener">NFS服务器中的showmount问题</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中恰好遇到了nfs共享文件目录的问题，以前也只是了解nfs服务，但没有实际安装与配置该服务，因而开始折腾的时候，问题很多，也查了很多资料。nfs服务安装配置很简单，问题不大，阻碍着我的是防火墙的配置，小白表示很无奈，这篇文章也是为了记录一下学习过程，方便日后查看。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://iholo.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://iholo.me/tags/Linux/"/>
    
      <category term="nfs" scheme="http://iholo.me/tags/nfs/"/>
    
  </entry>
  
  <entry>
    <title>Linux下的tar压缩解压缩命令详解</title>
    <link href="http://iholo.me/posts/aa48d35b/"/>
    <id>http://iholo.me/posts/aa48d35b/</id>
    <published>2017-07-01T20:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure></p><p>下面的参数-f是必须的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br><span class="line"></span><br><span class="line"># tar -cf all.tar *.jpg</span><br><span class="line">这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</span><br><span class="line"></span><br><span class="line"># tar -rf all.tar *.gif</span><br><span class="line">这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</span><br><span class="line"></span><br><span class="line"># tar -uf all.tar logo.gif</span><br><span class="line">这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</span><br><span class="line"></span><br><span class="line"># tar -tf all.tar</span><br><span class="line">这条命令是列出all.tar包中所有文件，-t是列出文件的意思</span><br><span class="line"></span><br><span class="line"># tar -xf all.tar</span><br><span class="line">这条命令是解出all.tar包中所有文件，-t是解开的意思</span><br></pre></td></tr></table></figure></p><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg </span><br><span class="line"></span><br><span class="line">tar -czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span><br><span class="line"></span><br><span class="line"> tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span><br><span class="line"></span><br><span class="line">tar -cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span><br><span class="line"></span><br><span class="line">rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux</span><br><span class="line"></span><br><span class="line">zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf file.tar //解压 tar包</span><br><span class="line"></span><br><span class="line">tar -xzvf file.tar.gz //解压tar.gz</span><br><span class="line"></span><br><span class="line">tar -xjvf file.tar.bz2   //解压 tar.bz2</span><br><span class="line"></span><br><span class="line">tar -xZvf file.tar.Z   //解压tar.Z</span><br><span class="line"></span><br><span class="line">unrar e file.rar //解压rar</span><br><span class="line"></span><br><span class="line">unzip file.zip //解压zip</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、*.tar 用 tar -xvf 解压</span><br><span class="line"></span><br><span class="line">2、*.gz 用 gzip -d或者gunzip 解压</span><br><span class="line"></span><br><span class="line">3、*.tar.gz和*.tgz 用 tar -xzf 解压</span><br><span class="line"></span><br><span class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压</span><br><span class="line"></span><br><span class="line">5、*.tar.bz2用tar -xjf 解压</span><br><span class="line"></span><br><span class="line">6、*.Z 用 uncompress 解压</span><br><span class="line"></span><br><span class="line">7、*.tar.Z 用tar -xZf 解压</span><br><span class="line"></span><br><span class="line">8、*.rar 用 unrar e解压</span><br><span class="line"></span><br><span class="line">9、*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/qq78292959/archive/2011/07/06/2099427.html" target="_blank" rel="noopener">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tar&quot;&gt;&lt;a href=&quot;#tar&quot; class=&quot;headerlink&quot; title=&quot;tar&quot;&gt;&lt;/a&gt;tar&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-c: 建立压缩档案&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-x：解压&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-t：查看内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-r：向压缩归档文件末尾追加文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-u：更新原压缩包中的文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://iholo.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://iholo.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Commons Email组件的使用</title>
    <link href="http://iholo.me/posts/e0836185/"/>
    <id>http://iholo.me/posts/e0836185/</id>
    <published>2017-05-24T20:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Apache Commons Eamil组件在Java mail的基础上进行了封装，简化了邮件的发送,它提供了几个类用于不同email类型的发送.<br><a id="more"></a></p><table><thead><tr><th>类</th><th style="text-align:right">作用</th></tr></thead><tbody><tr><td>SimpleEmail</td><td style="text-align:right">用于简单邮件的发送</td></tr><tr><td>MultiPartEmail</td><td style="text-align:right">包含附件类型的邮件</td></tr><tr><td>HtmlEmail</td><td style="text-align:right">HTML格式的文本邮件</td></tr><tr><td>ImageHtmlEmail</td><td style="text-align:right">用于发送包含HTML模板的邮件</td></tr><tr><td>EmailAttachment</td><td style="text-align:right">定义邮件附件</td></tr></tbody></table><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h2><p>官网下载：<a href="https://commons.apache.org/proper/commons-email/download_email.cgi" target="_blank" rel="noopener">Apache Commons Email 1.4</a></p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-email&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>NOTE: Commons Email 依赖  <code>javax.mail</code>，<code>javax.activation</code></p></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="SimpleEmail"><a href="#SimpleEmail" class="headerlink" title="SimpleEmail"></a>SimpleEmail</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Email email = new SimpleEmail();</span><br><span class="line">email.setHostName(&quot;smtp.qq.com&quot;);</span><br><span class="line">email.setSmtpPort(465);</span><br><span class="line">email.setAuthentication(&quot;userName&quot;, &quot;passWord&quot;);</span><br><span class="line">email.setSSLOnConnect(true);</span><br><span class="line">email.setFrom(&quot;user@qq.com&quot;);</span><br><span class="line">email.setSubject(&quot;邮件主题&quot;);</span><br><span class="line">email.setMsg(&quot;邮件内容&quot;);</span><br><span class="line">email.addTo(&quot;foo@bar.com&quot;);</span><br><span class="line">email.send();</span><br></pre></td></tr></table></figure><h2 id="MultiPartEmail"><a href="#MultiPartEmail" class="headerlink" title="MultiPartEmail"></a>MultiPartEmail</h2><p><code>MultiPartEmail</code>用于发送包含附件的邮件，其中附件使用<code>EmailAttachment</code>构建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EmailAttachment attachment = new EmailAttachment();</span><br><span class="line">attachment.setPath(&quot;D:\\Users\\1.txt&quot;);</span><br><span class="line">attachment.setName(&quot;照片&quot;);</span><br><span class="line">attachment.setDescription(&quot;附件描述&quot;);</span><br><span class="line"></span><br><span class="line">MultiPartEmail email = new MultiPartEmail();</span><br><span class="line">email.setHostName(HOST_NAME);</span><br><span class="line">email.setSmtpPort(SMTP_PORT);</span><br><span class="line">email.setAuthentication(USER_NAME, PASS_WORD);</span><br><span class="line">email.setFrom(&quot;user@qq.com&quot;);</span><br><span class="line">email.addTo(&quot;touser@gmail.com&quot;);</span><br><span class="line">email.setSubject(&quot;附件邮件测试&quot;);</span><br><span class="line">email.setMsg(&quot;正文测试&quot;);</span><br><span class="line">email.attach(attachment);</span><br><span class="line">String str=email.send();</span><br></pre></td></tr></table></figure></p><h2 id="HtmlEmail"><a href="#HtmlEmail" class="headerlink" title="HtmlEmail"></a>HtmlEmail</h2><p><code>HtmlEmail</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HtmlEmail email = <span class="keyword">new</span> HtmlEmail();</span><br><span class="line">email.setHostName(<span class="string">"mail.myserver.com"</span>);</span><br><span class="line">email.addTo(<span class="string">"jdoe@somewhere.org"</span>, <span class="string">"John Doe"</span>);</span><br><span class="line">email.setFrom(<span class="string">"me@apache.org"</span>, <span class="string">"Me"</span>);</span><br><span class="line">email.setSubject(<span class="string">"Test email with inline image"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// embed the image and get the content id</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.apache.org/images/asf_logo_wide.gif"</span>);</span><br><span class="line">String cid = email.embed(url, <span class="string">"Apache logo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the html message</span></span><br><span class="line">email.setHtmlMsg(<span class="string">"&lt;html&gt;The apache logo - &lt;img src=\"cid:"</span>+cid+<span class="string">"\"&gt;&lt;/html&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the alternative message</span></span><br><span class="line">email.setTextMsg(<span class="string">"Your email client does not support HTML messages"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// send the email</span></span><br><span class="line">email.send();</span><br></pre></td></tr></table></figure><h2 id="ImageHtmlEmail"><a href="#ImageHtmlEmail" class="headerlink" title="ImageHtmlEmail"></a>ImageHtmlEmail</h2><p><code>ImageHtmlEmail</code>用于发送固定HTML模板的邮件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load your HTML email template</span></span><br><span class="line">  String htmlEmailTemplate = <span class="string">".... &lt;img src=\"http://www.apache.org/images/feather.gif\"&gt; ...."</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// define you base URL to resolve relative resource locations</span></span><br><span class="line">  URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.apache.org"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create the email message</span></span><br><span class="line">  ImageHtmlEmail email = <span class="keyword">new</span> ImageHtmlEmail();</span><br><span class="line">  email.setDataSourceResolver(<span class="keyword">new</span> DataSourceUrlResolver(url));</span><br><span class="line">  email.setHostName(<span class="string">"mail.myserver.com"</span>);</span><br><span class="line">  email.addTo(<span class="string">"jdoe@somewhere.org"</span>, <span class="string">"John Doe"</span>);</span><br><span class="line">  email.setFrom(<span class="string">"me@apache.org"</span>, <span class="string">"Me"</span>);</span><br><span class="line">  email.setSubject(<span class="string">"Test email with inline image"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set the html message</span></span><br><span class="line">  email.setHtmlMsg(htmlEmailTemplate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the alternative message</span></span><br><span class="line">  email.setTextMsg(<span class="string">"Your email client does not support HTML messages"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send the email</span></span><br><span class="line">  email.send();</span><br></pre></td></tr></table></figure></p><hr><p>参考:<a href="https://commons.apache.org/proper/commons-email/index.html" target="_blank" rel="noopener">Commail Email官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;Apache Commons Eamil组件在Java mail的基础上进行了封装，简化了邮件的发送,它提供了几个类用于不同email类型的发送.&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://iholo.me/categories/Java/"/>
    
    
      <category term="java" scheme="http://iholo.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Linux firewalld的简单使用</title>
    <link href="http://iholo.me/posts/10442c59/"/>
    <id>http://iholo.me/posts/10442c59/</id>
    <published>2017-03-06T20:46:25.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<p>Firewalld 是 iptables 的前端控制器，用于实现持久的网络流量规则。它提供命令行和图形界面，在大多数 Linux 发行版的仓库中都有,Firewalld 提供了支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具。它支持 IPv4, IPv6 防火墙设置以及以太网桥接，并且拥有运行时配置和永久配置选项。它也支持允许服务或者应用程序直接添加防火墙规则的接口。</p><p><img src="/images/RHEL_Security-Guide_453350_0717_ECE_firewalld-comparison.png" alt=""><br><a id="more"></a></p><h2 id="Firewalld安装管理"><a href="#Firewalld安装管理" class="headerlink" title="Firewalld安装管理"></a>Firewalld安装管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum install firewalld      安装</span><br><span class="line">systemctl start firewalld 启动服务</span><br><span class="line">systemctl stop firewalld 关闭服务</span><br><span class="line">systemctl status firewalld 查看服务状态</span><br><span class="line">systemctl-cmd --state</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld 禁用Firewalld服务</span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld  启用Firewalld服务</span><br><span class="line">systemctl unmask firewalld  屏蔽Firewalld服务</span><br></pre></td></tr></table></figure><h2 id="zone概念"><a href="#zone概念" class="headerlink" title="zone概念"></a>zone概念</h2><p>Firewall 能将不同的网络连接归类到不同的信任级别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all-zones 查看所有zone信息</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">drop: 丢弃所有进入的包，而不给出任何响应</span><br><span class="line">block: 拒绝所有外部发起的连接，允许内部发起的连接</span><br><span class="line">public: 允许指定的进入连接</span><br><span class="line">external: 同上，对伪装的进入连接，一般用于路由转发</span><br><span class="line">dmz: 允许受限制的进入连接</span><br><span class="line">work: 允许受信任的计算机被限制的进入连接，类似 workgroup</span><br><span class="line">home: 同上，类似 homegroup</span><br><span class="line">internal: 同上，范围针对所有互联网用户</span><br><span class="line">trusted: 信任所有连接</span><br></pre></td></tr></table></figure><p>过滤规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source: 根据源地址过滤</span><br><span class="line">interface: 根据网卡过滤</span><br><span class="line">service: 根据服务名过滤</span><br><span class="line">port: 根据端口过滤</span><br><span class="line">icmp-block: icmp 报文过滤，按照 icmp 类型配置</span><br><span class="line">masquerade: ip 地址伪装</span><br><span class="line">forward-port: 端口转发</span><br><span class="line">rule: 自定义规则</span><br></pre></td></tr></table></figure></p><p>过滤规则的优先级遵循如下顺序 source&gt;interface&gt;firewalld.conf</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports 查看开放的端口</span><br><span class="line">firewall-cmd --zone=public --query-port=80/tcp 查询端口开放情况</span><br></pre></td></tr></table></figure><h2 id="开放服务端口"><a href="#开放服务端口" class="headerlink" title="开放服务端口"></a>开放服务端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent 开启端口，–permanent参数表明该规则永久生效，否则，重启后则失效</span><br></pre></td></tr></table></figure><h2 id="删除端口"><a href="#删除端口" class="headerlink" title="删除端口"></a>删除端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent 删除端口</span><br><span class="line">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;222.222.222.222&apos; reject&quot; 封IP</span><br><span class="line">firewall-cmd --permanent --zone=public --new-ipset=blacklist --type=hash:net</span><br><span class="line">firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=222.222.222.0/24  封禁网段</span><br></pre></td></tr></table></figure><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-forward-port=port=80:proto=tcpLtoport=8080 把本机端口80转发到8080</span><br></pre></td></tr></table></figure><p>端口转发到其他服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-masquerade 先激活masquerade</span><br><span class="line">firewall-cmd --zone=<span class="string">"public"</span> --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=45.32.42.158 本地的 80 端口的流量转发到 IP 地址为 ：45.32.42.158 的远程服务器上的  8080 端口</span><br><span class="line">firewall-cmd --zone=public --remove-masquerade 删除规则</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd [ --zone=&lt;zone&gt; ] --list-services 列举区域开启的服务</span><br></pre></td></tr></table></figure><p>常见示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">允许来自主机 192.168.0.14 的所有 IPv4 流量</span><br><span class="line">firewall-cmd --zone=public --add-rich-rule &apos;rule family=&quot;ipv4&quot; source address=192.168.0.14 accept&apos;</span><br><span class="line"></span><br><span class="line">拒绝来自主机 192.168.1.10 到 22 端口的 IPv4 的 TCP 流量</span><br><span class="line">firewall-cmd --zone=public --add-rich-rule &apos;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.10&quot; port port=22 protocol=tcp reject&apos;</span><br><span class="line"></span><br><span class="line">允许来自主机 10.1.0.3 到 80 端口的 IPv4 的 TCP 流量，并将流量转发到 6532 端口上</span><br><span class="line">firewall-cmd --zone=public --add-rich-rule &apos;rule family=ipv4 source address=10.1.0.3 forward-port port=80 protocol=tcp to-port=6532&apos;</span><br><span class="line"></span><br><span class="line">将主机 172.31.4.2 上 80 端口的 IPv4 流量转发到 8080 端口（需要在区域上激活 masquerade）</span><br><span class="line">firewall-cmd --zone=public --add-rich-rule &apos;rule family=ipv4 forward-port port=80 protocol=tcp to-port=8080 to-addr=172.31.4.2&apos;</span><br><span class="line">firewall-cmd --list-rich-rules 列出当前的丰富规则：</span><br></pre></td></tr></table></figure><p>参考:</p><blockquote><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-using_firewalls" target="_blank" rel="noopener">Redhat使用防火墙</a><br><a href="https://linux.cn/article-8098-1.html" target="_blank" rel="noopener">Linux中国</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Firewalld 是 iptables 的前端控制器，用于实现持久的网络流量规则。它提供命令行和图形界面，在大多数 Linux 发行版的仓库中都有,Firewalld 提供了支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具。它支持 IPv4, IPv6 防火墙设置以及以太网桥接，并且拥有运行时配置和永久配置选项。它也支持允许服务或者应用程序直接添加防火墙规则的接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/RHEL_Security-Guide_453350_0717_ECE_firewalld-comparison.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://iholo.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://iholo.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux ufw介绍安装与配置</title>
    <link href="http://iholo.me/posts/aa48d35b/"/>
    <id>http://iholo.me/posts/aa48d35b/</id>
    <published>2017-03-05T16:47:54.000Z</published>
    <updated>2019-11-02T08:24:33.257Z</updated>
    
    <content type="html"><![CDATA[<hr><p>##1.ufw介绍</p><blockquote><p>ufw是一个主机端的iptables类防火墙配置工具，比较容易上手。一般桌面应用使用ufw已经可以满足要求了。</p></blockquote><p>##2.安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ufw</span><br></pre></td></tr></table></figure></p><p>##3.使用方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">enable</span>  启用ufw</span><br><span class="line">sudo ufw <span class="built_in">disable</span> 关闭ufw</span><br><span class="line">sudo ufw default deny 关闭所有外部对本机的访问</span><br><span class="line">sudo ufw status 查看防火墙状态</span><br><span class="line">sudo ufw reset 重置防火墙，会先备份配置之后清除并停用防火墙</span><br><span class="line">sudo ufw reload 刷新防火墙</span><br></pre></td></tr></table></figure></p><p>开启/禁用相应端口或服务举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 80 允许外部访问80端口</span><br><span class="line">sudo ufw delete allow 80 禁止外部访问80 端口</span><br><span class="line">sudo ufw allow from 192.168.1.1 允许此IP访问所有的本机端口</span><br><span class="line">sudo ufw deny smtp 禁止外部访问smtp服务</span><br><span class="line">sudo ufw delete allow smtp 删除上面建立的某条规则</span><br><span class="line">sudo ufw deny proto tcp from 10.0.0.0/8 to 192.168.0.1 port 22 要拒绝所有的TCP流量从10.0.0.0/8 到192.168.0.1地址的22端口</span><br><span class="line"> 可以允许所有RFC1918网络（局域网/无线局域网的）访问这个主机（/8,/16,/12是一种网络分级）：</span><br><span class="line">sudo ufw allow from 10.0.0.0/8</span><br><span class="line">sudo ufw allow from 172.16.0.0/12</span><br><span class="line">sudo ufw</span><br></pre></td></tr></table></figure></p><blockquote><p><a href="http://wiki.ubuntu.org.cn/UFW%E9%98%B2%E7%81%AB%E5%A2%99%E7%AE%80%E5%8D%95%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">Ufw防火墙配置</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;##1.ufw介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ufw是一个主机端的iptables类防火墙配置工具，比较容易上手。一般桌面应用使用ufw已经可以满足要求了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##2.安装&lt;br&gt;&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://iholo.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://iholo.me/tags/Linux/"/>
    
  </entry>
  
</feed>
